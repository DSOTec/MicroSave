import{r as o}from"./react-vendor-DsKT7o15.js";import{B as P,J as _,f as T,p as x,C as A}from"./web3-vendor-D8WPf4F6.js";const D={MockERC20:"0x401A13415314b516079f017D79F0457C9E2A5B0D",SavingsPool:"0x925E885281d502883f1e75bd070BA45E30792CeF",ScoreRegistry:"0xf005ae51A9Ff6B3f3D6A41A640620450207B8758",RewardVault:"0xF04CE75D93186180aa807242a6e130d59f96FA1B"},S={chainId:4202,name:"Lisk Sepolia",rpcUrl:"https://rpc.sepolia-api.lisk.com",explorerUrl:"https://sepolia-blockscout.lisk.com"},z=["function balances(address user) view returns (uint256)","function totalDeposits() view returns (uint256)","function depositFeeBps() view returns (uint16)","function getUserDepositDays(address user) view returns (uint40[])","function deposit(uint256 amount)","function depositWithPermit(uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s)","function withdraw(uint256 amount)","function withdrawAll()","event Deposit(address indexed user, uint256 amount, uint256 fee, uint40 dayIndex)","event Withdraw(address indexed user, uint256 amount)"],q=["function getUserScore(address user) view returns (uint16)","function getUserStreak(address user) view returns (uint16)","function getUserStats(address user) view returns (uint16 score, uint16 streak, uint8 freq30)","event ScoreSet(address indexed user, uint16 score, uint16 streak, uint8 freq30)"],V=["function points(address user) view returns (uint256)","function POINTS_PER_DEPOSIT() view returns (uint256)","function STREAK_BONUS_POINTS() view returns (uint256)","event PointsAwarded(address indexed user, uint256 points, uint16 streak)"],$=["function balanceOf(address account) view returns (uint256)","function allowance(address owner, address spender) view returns (uint256)","function approve(address spender, uint256 amount) returns (bool)","function transfer(address to, uint256 amount) returns (bool)","function transferFrom(address from, address to, uint256 amount) returns (bool)","function decimals() view returns (uint8)","function symbol() view returns (string)","function name() view returns (string)","function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)","function nonces(address owner) view returns (uint256)","function DOMAIN_SEPARATOR() view returns (bytes32)","function mint(address to, uint256 amount)","function faucet(uint256 amount)","event Transfer(address indexed from, address indexed to, uint256 value)","event Approval(address indexed owner, address indexed spender, uint256 value)"];function I(n){const e=D[n];let t;switch(n){case"SavingsPool":t=z;break;case"ScoreRegistry":t=q;break;case"RewardVault":t=V;break;case"MockERC20":t=$;break;default:throw new Error(`Unknown contract: ${n}`)}return{address:e,abi:t}}class v{static instance;provider=null;signer=null;constructor(){}static getInstance(){return v.instance||(v.instance=new v),v.instance}async initializeProvider(){return this.provider?this.provider:typeof window<"u"&&window.ethereum?(this.provider=new P(window.ethereum),this.provider):(this.provider=new _(S.rpcUrl),this.provider)}async getSigner(){if(this.signer)return this.signer;const e=await this.initializeProvider();if(e instanceof P)return this.signer=await e.getSigner(),this.signer;throw new Error("No wallet connected. Please connect MetaMask or another wallet.")}async getProvider(){return await this.initializeProvider()}async connectWallet(){if(!window.ethereum)throw new Error("MetaMask not found. Please install MetaMask.");try{return await window.ethereum.request({method:"eth_requestAccounts"}),await this.switchToLiskSepolia(),await(await this.getSigner()).getAddress()}catch(e){throw console.error("Failed to connect wallet:",e),e}}async switchToLiskSepolia(){if(window.ethereum)try{await window.ethereum.request({method:"wallet_switchEthereumChain",params:[{chainId:`0x${S.chainId.toString(16)}`}]})}catch(e){if(e.code===4902)try{await window.ethereum.request({method:"wallet_addEthereumChain",params:[{chainId:`0x${S.chainId.toString(16)}`,chainName:S.name,rpcUrls:[S.rpcUrl],blockExplorerUrls:[S.explorerUrl],nativeCurrency:{name:"ETH",symbol:"ETH",decimals:18}}]})}catch(t){throw console.error("Failed to add network:",t),t}else throw e}}async getCurrentAccount(){if(!window.ethereum)return null;try{const e=await window.ethereum.request({method:"eth_accounts"});return e.length>0?e[0]:null}catch(e){return console.error("Failed to get current account:",e),null}}async isConnectedToLiskSepolia(){if(!window.ethereum)return!1;try{const e=await window.ethereum.request({method:"eth_chainId"});return parseInt(e,16)===S.chainId}catch(e){return console.error("Failed to check network:",e),!1}}reset(){this.provider=null,this.signer=null}}const m=v.getInstance(),b=n=>T(n,18),L=n=>x(n,18),Z=n=>`${n.slice(0,6)}...${n.slice(-4)}`,G=()=>{const[n,e]=o.useState({isConnected:!1,account:null,isCorrectNetwork:!1,isLoading:!0,error:null}),t=o.useCallback(async()=>{try{e(d=>({...d,isLoading:!0,error:null}));const r=await m.getCurrentAccount(),a=await m.isConnectedToLiskSepolia();e({isConnected:!!r,account:r,isCorrectNetwork:a,isLoading:!1,error:null})}catch(r){console.error("Failed to check connection:",r),e(a=>({...a,isLoading:!1,error:r instanceof Error?r.message:"Unknown error"}))}},[]),i=o.useCallback(async()=>{try{e(d=>({...d,isLoading:!0,error:null}));const r=await m.connectWallet(),a=await m.isConnectedToLiskSepolia();return e({isConnected:!0,account:r,isCorrectNetwork:a,isLoading:!1,error:null}),r}catch(r){throw console.error("Failed to connect wallet:",r),e(a=>({...a,isLoading:!1,error:r instanceof Error?r.message:"Failed to connect wallet"})),r}},[]),l=o.useCallback(()=>{m.reset(),e({isConnected:!1,account:null,isCorrectNetwork:!1,isLoading:!1,error:null})},[]),f=o.useCallback(async()=>{try{e(r=>({...r,isLoading:!0,error:null})),await m.switchToLiskSepolia(),await t()}catch(r){throw console.error("Failed to switch network:",r),e(a=>({...a,isLoading:!1,error:r instanceof Error?r.message:"Failed to switch network"})),r}},[t]);return o.useEffect(()=>{if(typeof window<"u"&&window.ethereum){const r=d=>{d.length===0?l():t()},a=()=>{t()};return window.ethereum.on("accountsChanged",r),window.ethereum.on("chainChanged",a),t(),()=>{window.ethereum?.removeListener("accountsChanged",r),window.ethereum?.removeListener("chainChanged",a)}}else e(r=>({...r,isLoading:!1}))},[t,l]),{...n,connect:i,disconnect:l,switchNetwork:f,checkConnection:t}},R=n=>{const[e,t]=o.useState(null),[i,l]=o.useState(!0),[f,r]=o.useState(null),a=o.useCallback(async(y=!1)=>{try{l(!0),r(null);const{address:g,abi:c}=I(n);if(y){const C=await m.getSigner(),k=new A(g,c,C);t(k)}else{const C=await m.getProvider(),k=new A(g,c,C);t(k)}}catch(g){console.error(`Failed to initialize ${n} contract:`,g),r(g instanceof Error?g.message:"Failed to initialize contract")}finally{l(!1)}},[n]);o.useEffect(()=>{a()},[a]);const d=o.useCallback(async()=>{await a(!0)},[a]);return{contract:e,isLoading:i,error:f,getContractWithSigner:d,reinitialize:a}},K=()=>R("SavingsPool"),H=()=>R("ScoreRegistry"),J=()=>R("RewardVault"),Y=()=>R("MockERC20"),tt=()=>{const{account:n,isConnected:e}=G(),{contract:t,getContractWithSigner:i}=K(),{contract:l}=H(),{contract:f}=J(),{contract:r,getContractWithSigner:a}=Y(),[d,y]=o.useState({balance:"0",tokenBalance:"0",allowance:"0",score:0,streak:0,points:"0",totalDeposits:"0"}),[g,c]=o.useState({isLoading:!1,error:null,hash:null}),[C,k]=o.useState(!1),w=o.useCallback(async()=>{if(!(!n||!t||!l||!f||!r))try{k(!0);const[u,s,h,[p,E],B,O]=await Promise.all([t.balances(n),r.balanceOf(n),r.allowance(n,t.target),l.getUserStats(n),f.points(n),t.totalDeposits()]);y({balance:b(u),tokenBalance:b(s),allowance:b(h),score:Number(p),streak:Number(E),points:B.toString(),totalDeposits:b(O)})}catch(u){console.error("Failed to fetch user stats:",u)}finally{k(!1)}},[n,t,l,f,r]),M=o.useCallback(async u=>{if(!n||!t||!r)throw new Error("Wallet not connected or contracts not ready");try{c({isLoading:!0,error:null,hash:null}),await i(),await a();const s=L(u);await a(),await(await r.approve(t.target,s)).wait(),await i();const E=await(await t.deposit(s)).wait();return c({isLoading:!1,error:null,hash:E.hash}),await w(),E}catch(s){const h=s instanceof Error?s.message:"Deposit failed";throw c({isLoading:!1,error:h,hash:null}),s}},[n,t,r,i,a,w]),U=o.useCallback(async u=>{if(!n||!t)throw new Error("Wallet not connected or contract not ready");try{c({isLoading:!0,error:null,hash:null}),await i();const s=L(u),p=await(await t.withdraw(s)).wait();return c({isLoading:!1,error:null,hash:p.hash}),await w(),p}catch(s){const h=s instanceof Error?s.message:"Withdrawal failed";throw c({isLoading:!1,error:h,hash:null}),s}},[n,t,i,w]),F=o.useCallback(async()=>{if(!n||!t)throw new Error("Wallet not connected or contract not ready");try{c({isLoading:!0,error:null,hash:null}),await i();const s=await(await t.withdrawAll()).wait();return c({isLoading:!1,error:null,hash:s.hash}),await w(),s}catch(u){const s=u instanceof Error?u.message:"Withdrawal failed";throw c({isLoading:!1,error:s,hash:null}),u}},[n,t,i,w]),N=o.useCallback(async(u="1000")=>{if(!n||!r)throw new Error("Wallet not connected or token contract not ready");try{c({isLoading:!0,error:null,hash:null}),await a();const s=L(u),p=await(await r.faucet(s)).wait();return c({isLoading:!1,error:null,hash:p.hash}),await w(),p}catch(s){const h=s instanceof Error?s.message:"Faucet failed";throw c({isLoading:!1,error:h,hash:null}),s}},[n,r,a,w]),W=o.useCallback(()=>{c({isLoading:!1,error:null,hash:null})},[]);return o.useEffect(()=>{e&&n&&w()},[e,n,w]),{userStats:d,isLoading:C,txState:g,deposit:M,withdraw:U,withdrawAll:F,getTestTokens:N,fetchUserStats:w,clearTxState:W}};class j{provider=null;signer=null;contracts={};async initialize(){try{if(typeof window<"u"&&window.ethereum){this.provider=new P(window.ethereum),this.signer=await this.provider.getSigner();const e=["SavingsPool","ScoreRegistry","RewardVault","MockERC20"];for(const t of e){const{address:i,abi:l}=I(t);this.contracts[t]=new A(i,l,this.signer)}return!0}return!1}catch(e){return console.error("Failed to initialize contract service:",e),!1}}async getUserSavingsData(e){try{if(!this.contracts.SavingsPool||!this.contracts.ScoreRegistry||!this.contracts.RewardVault)throw new Error("Contracts not initialized");const[t,i,l,f,r]=await Promise.all([this.contracts.SavingsPool.balances(e),this.contracts.ScoreRegistry.getUserStats(e),this.contracts.RewardVault.points(e),this.contracts.SavingsPool.getUserDepositDays(e),this.contracts.SavingsPool.totalDeposits()]),a=f.map(y=>Number(y)),d=a.length>0?Math.max(...a):null;return{balance:T(t,18),score:Number(i.score),streak:Number(i.streak),frequency:Number(i.freq30),points:Number(l),depositDays:a,lastDepositDay:d,totalDeposits:T(r,18)}}catch(t){return console.error("Error fetching user savings data:",t),null}}async deposit(e){try{if(!this.contracts.SavingsPool||!this.contracts.MockERC20)throw new Error("Contracts not initialized");const t=x(e,18);return await(await this.contracts.MockERC20.approve(D.SavingsPool,t)).wait(),await(await this.contracts.SavingsPool.deposit(t)).wait(),!0}catch(t){return console.error("Error making deposit:",t),!1}}async withdraw(e){try{if(!this.contracts.SavingsPool)throw new Error("SavingsPool contract not initialized");const t=x(e,18);return await(await this.contracts.SavingsPool.withdraw(t)).wait(),!0}catch(t){return console.error("Error making withdrawal:",t),!1}}async getTokenBalance(e){try{if(!this.contracts.MockERC20)throw new Error("MockERC20 contract not initialized");const t=await this.contracts.MockERC20.balanceOf(e);return T(t,18)}catch(t){return console.error("Error fetching token balance:",t),"0"}}async mintTokens(e){try{if(!this.contracts.MockERC20)throw new Error("MockERC20 contract not initialized");const t=x(e,18);return await(await this.contracts.MockERC20.faucet(t)).wait(),!0}catch(t){return console.error("Error minting tokens:",t),!1}}getCurrentUserAddress(){return this.signer?this.signer.getAddress():null}}const et=new j;export{S as N,tt as a,et as c,Z as f,G as u};
